clc;
clear;
close all;

% We will use DCT to compress 8 x 8 blocks of the images
block_size = 8;

% Prepare image of choice
img_of_choice = rgb2gray(imread('pisa.jpg'));

% Array to store names of images being used
img_names = ["Monarch.mat", "Parrots.mat", "cameraman.mat"];
num_imgs = size(img_names, 2);

% Array with quality levels to be used for each of the images
quality_levels = [80, 30, 15];
num_quality_levels = size(quality_levels, 2);

% Load each image and perform the relevant tasks
for i = 0:num_imgs
    if i == 0
        img = img_of_choice;
        disp("Image of Choice");
    else
        img = load(img_names(i));
        fn = fieldnames(img);
        img = img.(fn{1});
    
        disp("Image: " + img_names(i));
    end

    figure;
    t = tiledlayout(1, num_quality_levels+1,'TileSpacing', 'compact', 'Padding', 'compact');

    nexttile;
    imshow(img, [], 'Border', 'tight');
    title("Original Image");

    for quality_level = quality_levels
        % Extract the corresponding quality level
        quality_level = quality_levels(quality_level_idx - 1);
        disp("At " + quality_level + "% Compression");

        % Compress and decompress
        [compressed, num_zeros, num_zeros_percent] = compress_img(img, block_size, quality_level);
        % Typically there would be a coding and decoding step here, but we
        % skip this step
        decompressed = decompress_img(compressed, block_size, quality_level);

        % Add a subplot and display the reconstructed image
        % subplot(1, num_quality_levels+1, quality_level_idx);
        nexttile;
        imshow(decompressed, [], 'Border', 'tight');
        title(quality_level + "% Compression");
        
        % Compute the PSNR
        psnr_ = psnr(img, decompressed);
        disp("PSNR = " + psnr_);

        % Display the number of zeros
        disp("Number of zeros = " + num_zeros + " (" + num_zeros_percent + "%)");
    end
end